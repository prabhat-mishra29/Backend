[Check out the data modeling structure of mega project in eraser.io]

#Project Structure Steps:-

    1. Create package.json using npm init.

    2.Let's discuss how we store our images?
        > We will upload the photos to AWS, Cloudinary, and Azure. The platforms will respond to an API to be used for future cases..
        >But sometimes user loses their connection so better way to store these photos and videos in our temporary server. After that, we use some processes to put these images into AWS, Cloudinary, and Azure.

    3.Create a 'public' folder then create a 'temp' folder inside it.

    4. Git tracks files, not folders. If you create a folder inside another folder and try to push it to GitHub, an empty file will be displayed. 
        > So how will you do then ?
        > Using '.gitkeep' , It is an empty file.

    5.Create .gitignore, .env file and .env.sample .
        > You can ignore project files for a specific project using "git ignore generators".

    6.Create a 'src' folder in main/root.within that create app.jsx file , index.js file and constants.js file.

    7.Go to the package.json and make 'type' as 'module'.
        >Whenever server file reloads , we need to stop and restart the server.Do we do everytime?
        >No, We use 'nodemon'.
        >'nodemon' is a tool that helps develop Node.js based applications by automatically restarting the node application when file changes in the directory are detected.
        >Here we install nodemon as a development dependency:
            "npm install --save-dev nodemon"
        >'Dev dependencies' are packages that are only required for local development and testing, and not for the production environment.
        >After installing nodemon, we need to direct it so that it automatically restarts whenever we hit 'npm run dev'. [go to the package.json]

    8.Go to src and create "controllers folder"[functionality] , "db folder"[database connection logic] , "middlewares folder"[It is a function that is executed between the request and response cycles of an application.{like it checks your cookies to see if you can get your information from response or not?}] , "models folder"[data modeling] , "routes folder"[routing] , "utils folder"[utility:-joo functionality baar baar repeat hoga usko ekk separate file pai rakhke,jahan v jarurat hoo use kiya jaye.]

    9.what is the use of prettier?
        > Prettier ensures consistency in your code formatting and makes the process automatic.
        > Learn about prettier.
        > install dev-dependency of prettier :- npm install -D prettier
        > add some additional file:- '.prettierrc' and '.prettierignore'


# How to connect database steps:-
    > Here we use mongoDB online service i.e 'mongoDB atlas'.
    
    1.Go to mongoDB atlas and make your account.

    2.To learn how to create your account and access other features, please refer to video number 7.

    3.In MongoDB, a cluster is a server instance that is formed by multiple instances of MongoDB code running through sharding and/or replication.

    4.In most cases, we deal with network and database access.
        network access:-Create your IP address.
        database access:-Create a database user.

    5.When connecting to MongoDB, you need an IP address, a username with a password, and a String.
        >String comes when you connect to cluster0 using compass or various methods. [mongoDB URL]

    6.Go to the .env file and save your mongoDB URL in it.

    7.Please access the constants file and create a name for the database. Then, export the created name.

    8.install 'dotenv','express','mongoose' package.

    9."Two things you must remember befor connecting with database":-
        >"Database is always in another continent."
        >Use try-catch and promises[resolve and reject] for avoiding errors.

    10.Mongoose is the one using which we can connect our database.

    11.We have two options for database connection.
        >1st one is we insert all codes to the index.js file and then execute. Whenever that data-connection code hits it executes immediately.
        
        >2nd one is create a DB folder and insert your connection code there , then import this folder to index.js file.

        >We use 2nd one.
    
    12.Go to the index.js and connect your database using mongoose. [for 1st approach]

    13.Go to the DB folder.[For 2nd approach]

    14.Go to 'app.js' and create an express app then import it on index.js.

    15.You may encounter an error stating that the file cannot be imported. If this occurs, always check your import statement. If the extension is missing, make sure to add it. [like db.js,constants.js etc]

    16.Agar .env pai kuch change hua toh dubara reload karo.

    17.If you get this error:-MongooseServerSelectionError: Could not connect to any servers in your MongoDB Atlas cluster. One common reason is that you're trying to access the database from an IP that isn't whitelisted.
        >Simply switch between wifi and mobile data to fix the issue.


# Custom API response and error handeling:-
    1.Generally, we lie in two states i.e. request and response of expressJS.

    2.Learn everything about request and response properties in expressJS documentation.

    3.In our observation, we consider only req.body,req.cookies and req.params.

    4.install 'cookie-parser' middleware and 'cors'.
        >CORS is a node.js package for providing a Connect/Express middleware that can be used to enable CORS with various options.
            - "app.use()" -> it is used when we have a middleware or configuration.

        >Cookie parser typically performs the following tasks: Extracts the cookie data from the HTTP request and converts it into a usable format that can be accessed by the server-side code.

    5.Go to 'app.js' and check out how to use CORS , cookie-parser and set some rules.

    6.Draw a diagram to understand middleware in eraser.io .
        >Some information nedd to be updated:-
            app.get('/instagram', (err,req,res,next) => {
                res.send('Hello World!')
            })
            - 'next' serves as a flag to pass on the reference to the next middleware until it reaches the response part.

    7.We always talk with database.
        > Did we need to use the database connection code again and again? :- No , To simplify this process, we create a utility file. This file can be imported whenever we need to use its functions or methods.
        > It acts as a wrapper.
            - We can use two different ways to do this.1st one is asyncHandler[using promises] and second one is try-catchHandler.

            - Go to utility folder -> asyncHandler.

    8.Now it is the time for creating a centralized format for handling errors.learn NodeJS API error. It returns a error-class.By overriding different methods we can improve error handling.
        - Go to utility folder -> APIerror

    9.For handling responses we do not use nodeJS because we have expressJS.But we can create a separate class for that and implement it for our use.
        - Go to utility folder -> APIresponse
    
    10.Learn about http status code.


# User and video model with hooks and JWT:-
    1.Go to eraser.io and watch user and video model.

    2.Create user model and video model in 'models' folder.

    3.Here we use a special type of package called "mongoose-aggregate-paginate-v2".
        > It is a pagination library designed specifically for handling paginated results from MongoDB aggregation queries in a Node.js application using Mongoose.

        > Pagination in MongoDB is a way to divide a large dataset into smaller, more manageable pieces.
        
        > In the context of databases, aggregation refers to the process of transforming and combining data from multiple documents or rows into a single result set based on specified criteria.  
        
        > MongoDB's aggregation framework operates using a pipeline model, where data flows through multiple stages of transformation. Each stage in the pipeline performs a specific operation on the data, such as filtering, grouping, or projecting, and passes the results to the next stage.

        >Use:-Go to video.model.

    4.For password encrypted-decrypted problem:- We use bcrypt/bcrypt.js.
        > A library to help you hash passwords.
            > bcrypt:-A bcrypt library for NodeJS.
            > bcrypt.js:-Optimized bcrypt in plain JavaScript with zero dependencies. Compatible to 'bcrypt'.
                - Both have same functionality.Which one would you prefer,it depends on you.
                - Here we use core 'bcrypt'.Install 'bcrypt'.

        
    5.For tokens we use JWT:-
        > JSON Web Tokens (JWTs) are a standardized way to securely send data between two parties. They contain information (claims) encoded in the JSON format. These claims help share specific details between the parties involved.
        > Learn about it on JWT.io .
        > Install jasonwebtokens .

    6.Both bcrypt and jasonwebtokens uses cryptography.

    7.Go to user.model and see how to use bcrypt,jasonwebtokens.

    8.Learn middleware hooks and methods from mongoose documentation.

    9.Learn difference bwtween access token vs referesh token.


# How to upload file in backend | Multer :-
    1.File handling doest not do in your own server , it uses either third party resources or AWS.Depend upon file size,calculation rate we choose resources.

    2.We make a separate utility/middleare for file uploader.We can use same code for image upload,pdf upload,video upload.
        > Depending on the type of end-points, we utilize middleware to interact with these end-points.

    3.We use 'cloudinary'.Create your own account and install it on VS-code.
    
    4.Strtegy to upload file:-
        > We will store these photos and videos in our temporary server.
        > After that, we use some processes to put these images into AWS, Cloudinary, and Azure.

        steps:-
            > Initially, we assumed that the file had already been uploaded to the local server, which gave us a local path.
            > using this local path we upload the file in 'cloudinary'.
            >After successfuly upload , we unlink/remove the file from local server.
            >Go to cloudinary.js .

    5.When you upload file,you got two packages.We use one of them.
        > 'express-fileupload' or 'multer'.We use 'multer'.
        > Install multer.

        > Multer is a node. js middleware for handling multipart/form-data , which is primarily used for uploading files from clients to the server in Node.js applications, typically in combination with frameworks like Express.js. 

        > We will create a middleware using multer.We directly configure multer but via middleware we can utilize it more effectively.

        > When we need this middleware we can import it. like in registration form.

        > Go to middleware and create 'multer' middleware for storing in disk storage.
        > Here we learn how to save 'file' in diskStorage.
        > learn about multer and how to use, how to upload  in their github documentation.


# HTTP crash course :-
    1.Hypertext Transfer Protocol.

    2.In 'HTTP' data goes in clear form.

    3.HTTPS is HTTP with encryption and verification.
    
    4.The only difference between the two protocols is that HTTPS uses TLS (SSL) to encrypt normal HTTP requests and responses, and to digitally sign those requests and responses.

    5.URI, URL, and URN are all types of strings that identify resources on the internet. 
    
    6.URI stands for Uniform Resource Identifier, URL stands for Uniform Resource Locator, and URN stands for Uniform Resource Name.

    7.HTTP headers:-
        >meta data.
        >HTTP headers let the client and the server pass additional information with an HTTP request or response.
        >Working:- Caching, authentication[bear token,refresh token,refresh key,refresh secret], manage state[user's state:-guest user,login user].
        >Types:-
            -Request headers:-
                Contain more information about the client requesting the resource.

            -Response headers:-
                Hold additional information about the response, like its location or about the server providing it.

            -Representation headers:-
                Contain information about the body of the resource, like its MIME type, or encoding/compression applied.
            
            -Payload headers:-
                Contain information about payload data, including content length and the encoding used for transport.

    8.Most common headers:-
        >Accept :- konsa format accept hoga.[ application/json or text/html ]
        >User-Agent :- konsi application se request ayaa hai.[ postman or browser{which type browser?} ]
        >Authentication :- [Bear_token]
        >Content-type :- which type content. [Images or videos]
        >Cookie :- [key value pair]
        >Cache-Control

    9.CORS headers:-
        >Access-Control-Allow-Origin
        >Access-Control-Allow-Credentials
        >Access-Control-Allow-Method

    10.Security policies headers:-
        >Cross-Origin-Embedder-Policy
        >Cross-Origin-Openers-Policy
        >Content-Security-Policy
        >X-XSS-Protection

    11.HTTP methods:-
        >Basic set of operations that can be used to interact with server.

            [ Most common :- GET , POST , PUT , DELETE , PATCH ]
            -GET :- retrieve a resource.
            -HEAD :- No body message,response headers only.
            -OPTIONS :- what operations are available.
            -TRACE :- loopback test (get some data)
            -DELETE :- remove a resource.
            -PUT :- replace a resource.
            -POST :- interact with resource (mostly add to server)
            -PATCH :- change part of a resource.

    12.HTTP response status codes:-
        >It indicate whether a specific HTTP request has been successfully completed. 
        >Responses are grouped in five classes:-
            -Informational responses (100 – 199)
            -Successful responses (200 – 299)
            -Redirection messages (300 – 399)
            -Client error responses (400 – 499)
            -Server error responses (500 – 599)

            100 - continue
            102 - processing
            200 - ok
            201 - created
            202 - accepted
            307 - temperary redirect
            308 - permanent redirect
            400 - bad request
            401 - unauthorized
            402 - payment required
            404 - not found
            500 - internal server error
            504 - gateway time out


# Complete guide for router and controller with debugging :-
    1. Controller:-is a part of the software that handles user inputs and makes decisions about what data should be presented to the user and how it should be presented.

    2. Router:-A router is a networking device that forwards data packets between computer networks. 

    3. Create a 'register' method. Go to user.controller.

    4. Now it is time for 'routers'.Go to routes and create user-routes.We perform all user related routes here.

    5. Import all routers in 'app.js'.

    6.We have many options for 'api-testing'.
        >We can use 'thunder-client' vs-code plugin.
        >We can use 'Post-man'.(we use this)
            - create your account in postman and test "http://localhost:8000/api/v1/users/register" in it's collection.

    7.In this module we just get basic guide for router and controller.In the next module, we will briefly discuss about it's use.

# 