[Check out the data modeling structure of mega project in eraser.io]

#Project Structure Steps:-

    1. Create package.json using npm init.

    2.Let's discuss how we store our images?
        > We will upload the photos to AWS, Cloudinary, and Azure. The platforms will respond to an API to be used for future cases..
        >But sometimes user loses their connection so better way to store these photos and videos in our temporary server. After that, we use some processes to put these images into AWS, Cloudinary, and Azure.

    3.Create a 'public' folder then create a 'temp' folder inside it.

    4. Git tracks files, not folders. If you create a folder inside another folder and try to push it to GitHub, an empty file will be displayed. 
        > So how will you do then ?
        > Using '.gitkeep' , It is an empty file.

    5.Create .gitignore, .env file and .env.sample .
        > You can ignore project files for a specific project using "git ignore generators".

    6.Create a 'src' folder in main/root.within that create app.jsx file , index.js file and constants.js file.

    7.Go to the package.json and make 'type' as 'module'.
        >Whenever server file reloads , we need to stop and restart the server.Do we do everytime?
        >No, We use 'nodemon'.
        >'nodemon' is a tool that helps develop Node.js based applications by automatically restarting the node application when file changes in the directory are detected.
        >Here we install nodemon as a development dependency:
            "npm install --save-dev nodemon"
        >'Dev dependencies' are packages that are only required for local development and testing, and not for the production environment.
        >After installing nodemon, we need to direct it so that it automatically restarts whenever we hit 'npm run dev'. [go to the package.json]

    8.Go to src and create "controllers folder"[functionality] , "db folder"[database connection logic] , "middlewares folder"[It is a function that is executed between the request and response cycles of an application.{like it checks your cookies to see if you can get your information from response or not?}] , "models folder"[data modeling] , "routes folder"[routing] , "utils folder"[utility:-joo functionality baar baar repeat hoga usko ekk separate file pai rakhke,jahan v jarurat hoo use kiya jaye.]

    9.what is the use of prettier?
        > Prettier ensures consistency in your code formatting and makes the process automatic.
        > Learn about prettier.
        > install dev-dependency of prettier :- npm install -D prettier
        > add some additional file:- '.prettierrc' and '.prettierignore'


# How to connect database steps:-
    > Here we use mongoDB online service i.e 'mongoDB atlas'.
    
    1.Go to mongoDB atlas and make your account.

    2.To learn how to create your account and access other features, please refer to video number 7.

    3.In MongoDB, a cluster is a server instance that is formed by multiple instances of MongoDB code running through sharding and/or replication.

    4.In most cases, we deal with network and database access.
        network access:-Create your IP address.
        database access:-Create a database user.

    5.When connecting to MongoDB, you need an IP address, a username with a password, and a String.
        >String comes when you connect to cluster0 using compass or various methods. [mongoDB URL]

    6.Go to the .env file and save your mongoDB URL in it.

    7.Please access the constants file and create a name for the database. Then, export the created name.

    8.install 'dotenv','express','mongoose' package.

    9."Two things you must remember befor connecting with database":-
        >"Database is always in another continent."
        >Use try-catch and promises[resolve and reject] for avoiding errors.

    10.Mongoose is the one using which we can connect our database.

    11.We have two options for database connection.
        >1st one is we insert all codes to the index.js file and then execute. Whenever that data-connection code hits it executes immediately.
        
        >2nd one is create a DB folder and insert your connection code there , then import this folder to index.js file.

        >We use 2nd one.
    
    12.Go to the index.js and connect your database using mongoose. [for 1st approach]

    13.Go to the DB folder.[For 2nd approach]

    14.Go to 'app.js' and create an express app then import it on index.js.

    15.You may encounter an error stating that the file cannot be imported. If this occurs, always check your import statement. If the extension is missing, make sure to add it. [like db.js,constants.js etc]

    16.Agar .env pai kuch change hua toh dubara reload karo.

    17.If you get this error:-MongooseServerSelectionError: Could not connect to any servers in your MongoDB Atlas cluster. One common reason is that you're trying to access the database from an IP that isn't whitelisted.
        >Simply switch between wifi and mobile data to fix the issue.


# Custom API response and error handeling:-
    1.Generally, we lie in two states i.e. request and response of expressJS.

    2.Learn everything about request and response properties in expressJS documentation.

    3.In our observation, we consider only req.body,req.cookies and req.params.

    4.install 'cookie-parser' middleware and 'cors'.
        >CORS is a node.js package for providing a Connect/Express middleware that can be used to enable CORS with various options.
            - "app.use()" -> it is used when we have a middleware or configuration.

        >Cookie parser typically performs the following tasks: Extracts the cookie data from the HTTP request and converts it into a usable format that can be accessed by the server-side code.

    5.Go to 'app.js' and check out how to use CORS , cookie-parser and set some rules.

    6.Draw a diagram to understand middleware in eraser.io .
        >Some information nedd to be updated:-
            app.get('/instagram', (err,req,res,next) => {
                res.send('Hello World!')
            })
            - 'next' serves as a flag to pass on the reference to the next middleware until it reaches the response part.

    7.We always talk with database.
        > Did we need to use the database connection code again and again? :- No , To simplify this process, we create a utility file. This file can be imported whenever we need to use its functions or methods.It acts as a wrapper.
            - We can use two different ways to do this.1st one is asyncHandler[using promises] and second one is try-catchHandler.

            - Go to utility folder -> asyncHandler.

    8.Now it is the time for creating a centralized format for handling errors.learn NodeJS API error. It returns a error-class.By overriding different methods we can improve error handling.
        - Go to utility folder -> APIerror

    9.For handling responses we do not use nodeJS because we have expressJS.But we can create a separate class for that and implement it for our use.
        - Go to utility folder -> APIresponse
    
    10.Learn about http status code.